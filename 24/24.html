<html>
<meta http-equiv="content-type" content="text/html;charset=UTF-8" />
<script type="text/javascript" src="24.js"></script>
<script type="text/javascript">
function log(obj){console.log(obj);}

// 判断是否为运算符
function isOperator(value) {
    var operatorString = "+-*/()";
    return operatorString.indexOf(value) > -1
}

// 获取运算符优先级，乘除高于加减
function getPrioraty(value) {
    switch (value) {
    case '+':
    case '-':
        return 1;
    case '*':
    case '/':
        return 2;
    default:
        return 0;
    }
}

// 比较运算符优先级
function prioraty(o1, o2) {
    return getPrioraty(o1) <= getPrioraty(o2);
}

// 定义输入、输出栈以及输出队列，循环逐个添加到输入栈的末尾，之后处理符号和数字，当找到 "(" 和 ")" 时特殊处理
function dal2Rpn(exp) {
    var inputStack = [];// 输入栈
    var outputStack = [];// 输出栈
    var outputQueue = [];// 输出队列

    for (var i = 0; i < exp.length; i++) {
        var cur = exp[i];
        if (cur != ' ') {
            inputStack.push(cur); // 将算式中的运算符和数字逐个添加到末尾
        }
    }
    // 处理字符和数字
    while (inputStack.length > 0) {
        // shift 顶部取得一项后移除，顶部取得一项后移除，unshift 顶部推入
        var cur = inputStack.shift();
        // 如果是符号 -->  + - * / ( )
        if (isOperator(cur)) {
            if (cur == '(') {
                // push 从尾部推入一项
                outputStack.push(cur);
            } else if (cur == ')') {
                // pop 从尾部取得一项，之后移出
                var po = outputStack.pop();
                while (po != '(' && outputStack.length > 0) {
                    outputQueue.push(po);
                    po = outputStack.pop();
                }
                if (po != '(') {
                    throw "错误：没有匹配";
                }
            } else { // 符号时，处理 + - * /
                while (prioraty(cur, outputStack[outputStack.length - 1]) && outputStack.length > 0) {
                    outputQueue.push(outputStack.pop());
                }
                outputStack.push(cur);
            }
        } else { // 是数字的时候，推入数字
            var cur2 = inputStack.shift();
            if (cur2 != null) {
                if (isOperator(cur2)) {
                    inputStack.unshift(cur2);
                } else {
                    cur = parseInt(cur) * 10 + parseInt(cur2);
                }
            }
            outputQueue.push(parseInt(cur));
        }
    }
    if (outputStack.length > 0) {
        if (outputStack[outputStack.length - 1] == ')' || outputStack[outputStack.length - 1] == '(') {
            throw "错误：没有匹配";
        }
        while (outputStack.length > 0) {
            outputQueue.push(outputStack.pop());
        }
    }
    // log(outputQueue);
    return outputQueue;
}

// 定义 evalRpn() 函数，输出堆栈的长度不小于2的时候，进行计算
function evalRpn(rpnQueue) {
    var outputStack = [];
    while (rpnQueue.length > 0) {
        var cur = rpnQueue.shift();

        if (!isOperator(cur)) {
            outputStack.push(cur);
        } else { // 如果输出堆栈长度小于 2
            if (outputStack.length < 2) {
                throw "无效堆栈长度";
            }
            var sec = outputStack.pop();
            var fir = outputStack.pop();

            var result = getResult(fir, sec, cur);
            outputStack.push(result);
            processStack.push(result);
        }
    }
    if (outputStack.length != 1) {
        throw "不正确的运算";
    } else {
        return outputStack[0];
    }
}

// 进行加减乘除计算之后，对其值进行操作，当浮点数的小数位超过两位时，只保留两位小数点
function getResult(first, second, operator) {
    var result = 0;
    switch (operator) {
    case '+':
        result = first + second;
        break;
    case '-':
        result = first - second;
        break;
    case '*':
        result = first * second;
        break;
    case '/':
        result = first / second;
        break;
    default:
        return 0;
    }

    // 浮点数的小数位超过两位时，只保留两位小数点
    function formatFloat(f, digit) {
        // pow(10,n) 为 10 的 n 次方
        var m = Math.pow(10, digit);
        return parseInt(f * m, 10) / m;
    }
    return (formatFloat(result, 2));
}

var difficultScore = 0;// 难度系数
var difficultScoreList = [];
var processStack = [];// 算式的计算过程值
// 解析算式复杂度
function analysisFormula(formula) {
    var score = 0;

    var addCount = countChar(formula, "+");// 算式包含加法，难度系数 1
    if (addCount > 0) {
        score += addCount * 1;
    }
    var subtractCount = countChar(formula, "-");// 算式包含减法，难度系数 2
    if (subtractCount > 0) {
        score += subtractCount * 2;
    }
    var multiplyCount = countChar(formula, "*");// 算式包含乘法，难度系数 2
    if (multiplyCount > 0) {
        score += multiplyCount * 2;
    }
    var divideCount = countChar(formula, "/");// 算式包含除法，难度系数 3
    if (divideCount > 0) {
        score += divideCount * 3;
    }
    var bracketsCount = countChar(formula, "(");// 算式包含括号，难度系数 2
    if (bracketsCount > 0) {
        score += bracketsCount * 2;
    }

    processStack = [];
    evalRpn(dal2Rpn(formula));// 计算算式的计算过程值
    // log(processStack)
    for (var i = 0; i < processStack.length - 1; i++) {
        var number = processStack[i];
        var decade = Math.floor(number / 10);
        if (number >= 100) {// 计算过程值包含三位数，难度系数 3
            score += 1;
        }
        if (number >= 50) {// 计算过程值包含50~99，难度系数 2
            score += 1;
        }
        if (number >= 20) {// 计算过程值包含20~49，难度系数 1
            score += 1;
        }
        if (number < 0) {// 计算过程值包含负数，难度系数 3
            score += 3;
        }
        if (String(number).indexOf(".") > -1) {// 计算过程值包含小数，难度系数 5
            score += 5;
        }
    }
    // log(score);
    return score;
}

// 计算字符串中指定字符出现的次数
function countChar(str, char) {
    var count = 0;
    for (var i = 0; i < str.length; i++) {
        if (str[i] == char) {
            count ++;
        }
    }
    return count;
}

var disoper = ["-", "+", "/", "*"];
function oper(f, m, n) {
  if (f == 3) return (m * n);
  if (f == 2) return (m / n);
  if (f == 1) return (parseFloat(m) + parseFloat(n));
  if (f == 0) return (m - n);
}
function tb(i1, i2, i4, i8) {
  this[1] = i1;
  this[2] = i2;
  this[4] = i4;
  this[8] = i8;
}
function valid(a, b, c, d) {
  var formulaList = [];
  b = new tb(a, b, c, d);
  for (i1 = 1; i1 <= 8; i1 *= 2) for (i2 = 1; i2 <= 8; i2 *= 2) for (i3 = 1; i3 <= 8; i3 *= 2) for (i4 = 1; i4 <= 8; i4 *= 2) {
    if ((i1 | i2 | i3 | i4) != 0xf) continue;
    for (f1 = 0; f1 <= 3; f1++) for (f2 = 0; f2 <= 3; f2++) for (f3 = 0; f3 <= 3; f3++) {
      m = oper(f3, oper(f2, oper(f1, b[i1], b[i2]), b[i3]), b[i4]);
      if (Math.abs(m - 24) < 1e-5) {
        formulaList.push("((" + b[i1] + disoper[f1] + b[i2] + ")" + disoper[f2] + b[i3] + ")" + disoper[f3] + b[i4]);
      }
      m = oper(f1, b[i1], oper(f3, oper(f2, b[i2], b[i3]), b[i4]));
      if (Math.abs(m - 24) < 1e-5) {
        formulaList.push(b[i1] + disoper[f1] + "((" + b[i2] + disoper[f2] + b[i3] + ")" + disoper[f3] + b[i4] + ")");
      }
      m = oper(f3, oper(f1, b[i1], oper(f2, b[i2], b[i3])), b[i4]);
      if (Math.abs(m - 24) < 1e-5) {
        formulaList.push("(" + b[i1] + disoper[f1] + "(" + b[i2] + disoper[f2] + b[i3] + "))" + disoper[f3] + b[i4]);
      }
      m = oper(f1, b[i1], oper(f2, b[i2], oper(f3, b[i3], b[i4])));
      if (Math.abs(m - 24) < 1e-5) {
        formulaList.push(b[i1] + disoper[f1] + "(" + b[i2] + disoper[f2] + "(" + b[i3] + disoper[f3] + b[i4] + "))");
      }
      m = oper(f2, oper(f1, b[i1], b[i2]), oper(f3, b[i3], b[i4]));
      if (Math.abs(m - 24) < 1e-5) {
        formulaList.push("(" + b[i1] + disoper[f1] + b[i2] + ")" + disoper[f2] + "(" + b[i3] + disoper[f3] + b[i4] + ")");
      }
    }
  }
  return formulaList;
}

// 判断数字组合是否已经计算过
function checkIsInResultList(targetList) {
    targetList.sort();
    for (var i = 0; i < resultList.length; i++) {
        var list = resultList[i];
        list = list.split("|");
        list = list[1];
        list = list.split(",");
        list.sort();
        if (list[0] == targetList[0] && list[1] == targetList[1] && list[2] == targetList[2] && list[3] == targetList[3]) {
            return true;
        }
    }
    return false;
}

var resultList = [];
var resultString = "";
function doTest2() {
    var start = 1, end = 20;
    var difficultScoreList = [];
    for (var a = start; a <= end; a++) {
        log(a);
        for (var b = start; b <= end; b++) {
            for (var c = start; c <= end; c++) {
                for (var d = start; d <= end; d++) {
                    if (checkIsInResultList([a, b, c, d])) {
                        continue;
                    }
                    var formulaList = valid(a, b, c, d);
                    var formulaScore = 9999;
                    var formula = "";
                    if (formulaList.length == 0) {
                        // log([a, b, c, d] + "无解");
                    } else {
                        for (var i = 0; i < formulaList.length; i++) {
                            var thisFormula = formulaList[i];
                            thisFormula = doBracket(thisFormula);
                            var score = analysisFormula(thisFormula);
                            if (score < formulaScore) {
                                formulaScore = score;
                                formula = thisFormula;
                            }
                        }
                        difficultScoreList.push(formulaScore);
                        resultList.push(formulaScore + "|" + [a, b, c, d] + "|" + formula);
                        // log(formulaScore + "|" + [a, b, c, d] + "|" + formula);
                        resultString += formulaScore + "|" + [a, b, c, d] + "|" + formula + "\n";
                    }
                }
            }
        }
    }
    var scoreList = [];
    for (var i = 0; i < difficultScoreList.length; i++) {
        var score = difficultScoreList[i];
        if (scoreList[score] == null) {
            scoreList[score] = 0;
        }
        scoreList[score] = scoreList[score] + 1;
    }
    log(resultString);
    log(difficultScoreList.length);
    log(scoreList);
}

var maxBracketCount = 0;
function doBracket(formula) {
    eval("var value=" + formula);
    // log(formula + "=" + value);
    var bracketCount = countChar(formula, "(");
    if (bracketCount > maxBracketCount) {
        maxBracketCount = bracketCount;
    }
    var formula0 = formula.replace(/\(/g, "").replace(/\)/g, "");
    try {
        eval("var value0=" + formula0);
        // log(formula0 + "=" + value0);
        if (value0 == value) {
            return formula0;
        }
    } catch (e) {}
    var leftBracketList = searchSubStr(formula, "(");
    var rightBracketList = searchSubStr(formula, ")");
    var formula1 = formula.substr(0, leftBracketList[0]) + formula.substr(leftBracketList[0] + 1, formula.length);
    formula1 = formula1.substr(0, rightBracketList[0] - 1) + formula1.substr(rightBracketList[0], formula.length);
    try {
        eval("var value1=" + formula1);
        // log(formula1 + "=" + value1);
        if (value1 == value) {
            return formula1;
        }
    } catch (e) {}
    var formula2 = formula.substr(0, leftBracketList[1]) + formula.substr(leftBracketList[1] + 1, formula.length);
    formula2 = formula2.substr(0, rightBracketList[1] - 1) + formula2.substr(rightBracketList[1], formula.length);
    try {
        eval("var value2=" + formula2);
        // log(formula2 + "=" + value2);
        if (value2 == value) {
            return formula2;
        }
    } catch (e) {}
    var formula3 = formula.substr(0, leftBracketList[0]) + formula.substr(leftBracketList[0] + 1, formula.length);
    formula3 = formula3.substr(0, rightBracketList[1] - 1) + formula3.substr(rightBracketList[1], formula.length);
    try {
        eval("var value3=" + formula3);
        // log(formula3 + "=" + value3);
        if (value3 == value) {
            return formula3;
        }
    } catch (e) {}
    var formula4 = formula.substr(0, leftBracketList[1]) + formula.substr(leftBracketList[1] + 1, formula.length);
    formula4 = formula4.substr(0, rightBracketList[0] - 1) + formula4.substr(rightBracketList[0], formula.length);
    try {
        eval("var value4=" + formula4);
        // log(formula4 + "=" + value4);
        if (value4 == value) {
            return formula4;
        }
    } catch (e) {}
    return formula;
}

function searchSubStr(str, subStr) {
    var positions = [];
    var pos = str.indexOf(subStr);
    while (pos > -1) {
        positions.push(pos);
        pos = str.indexOf(subStr, pos + 1);
    }
    return positions;
}

// doTest2();
// log(doBracket("((18*19)+18)/15"));
</script>
</html>